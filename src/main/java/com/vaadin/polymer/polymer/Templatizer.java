/*
 * This code was generated with Vaadin Web Component GWT API Generator, 
 * from polymer project by The Polymer Authors (http://polymer.github.io/AUTHORS.txt)
 * that is licensed with http://polymer.github.io/LICENSE.txt license.
 */
package com.vaadin.polymer.polymer;

import elemental2.dom.*;
import com.google.gwt.core.client.JavaScriptObject;
import elemental2.core.JsArray;
import jsinterop.annotations.JsOverlay;
import jsinterop.annotations.JsProperty;
import jsinterop.annotations.JsType;
import com.vaadin.polymer.PolymerFunction;


/**
 * <p>The <code>Polymer.Templatizer</code> behavior adds methods to generate instances of
 * templates that are each managed by an anonymous <code>Polymer.PropertyEffects</code>
 * instance where data-bindings in the stamped template content are bound to
 * accessors on itself.</p>
 * <p>This behavior is provided in Polymer 2.x as a hybrid-element convenience
 * only.  For non-hybrid usage, the <code>Polymer.Templatize</code> library
 * should be used instead.</p>
 * <p>Example:</p>
 * <pre><code>// Get a template from somewhere, e.g. light DOM
 * let template = this.querySelector(&#39;template&#39;);
 * // Prepare the template
 * this.templatize(template);
 * // Instance the template with an initial data model
 * let instance = this.stamp({myProp: &#39;initial&#39;});
 * // Insert the instance&#39;s DOM somewhere, e.g. light DOM
 * Polymer.dom(this).appendChild(instance.root);
 * // Changing a property on the instance will propagate to bindings
 * // in the template
 * instance.myProp = &#39;new value&#39;;
 * 
 * </code></pre><p>Users of <code>Templatizer</code> may need to implement the following abstract
 * API’s to determine how properties and paths from the host should be
 * forwarded into to instances:</p>
 * <pre><code>_forwardHostPropV2: function(prop, value)
 * 
 * </code></pre><p>Likewise, users may implement these additional abstract API’s to determine
 * how instance-specific properties that change on the instance should be
 * forwarded out to the host, if necessary.</p>
 * <pre><code>_notifyInstancePropV2: function(inst, prop, value)
 * 
 * </code></pre><p>In order to determine which properties are instance-specific and require
 * custom notification via <code>_notifyInstanceProp</code>, define an <code>_instanceProps</code>
 * object containing keys for each instance prop, for example:</p>
 * <pre><code>_instanceProps: {
 *   item: true,
 *   index: true
 * }
 * 
 * </code></pre><p>Any properties used in the template that are not defined in _instanceProp
 * will be forwarded out to the Templatize <code>owner</code> automatically.</p>
 * <p>Users may also implement the following abstract function to show or
 * hide any DOM generated using <code>stamp</code>:</p>
 * <pre><code>_showHideChildren: function(shouldHide)
 * 
 * </code></pre><p>Note that some callbacks are suffixed with <code>V2</code> in the Polymer 2.x behavior
 * as the implementations will need to differ from the callbacks required
 * by the 1.x Templatizer API due to changes in the <code>TemplateInstance</code> API
 * between versions 1.x and 2.x.</p>
 */
@JsType(isNative=true)
public interface Templatizer {

    @JsOverlay public static final String NAME = "Polymer.Templatizer";
    @JsOverlay public static final String SRC = "polymer/polymer.html";
    @JsOverlay public default <T> T cast() {
      return (T)this;
    }



    /**
     * <p>Generates an anonymous <code>TemplateInstance</code> class (stored as <code>this.ctor</code>)
     * for the provided template.  This method should be called once per
     * template to prepare an element for stamping the template, followed
     * by <code>stamp</code> to create new instances of the template.</p>
     *
     * JavaScript Info:
     * @method templatize
     * @param {!HTMLTemplateElement} template  
     * @param {boolean=} mutableData  
     * 
     * @return {JavaScriptObject}
     */
     JavaScriptObject templatize(JavaScriptObject template, boolean mutableData);

    /**
     * <p>Creates an instance of the template prepared by <code>templatize</code>.  The object
     * returned is an instance of the anonymous class generated by <code>templatize</code>
     * whose <code>root</code> property is a document fragment containing newly cloned
     * template content, and which has property accessors corresponding to
     * properties referenced in template bindings.</p>
     *
     * JavaScript Info:
     * @method stamp
     * @param {Object=} model  
     * 
     * @return {JavaScriptObject}
     */
     JavaScriptObject stamp(JavaScriptObject model);

    /**
     * <p>Returns the template “model” (<code>TemplateInstance</code>) associated with
     * a given element, which serves as the binding scope for the template
     * instance the element is contained in.  A template model should be used
     * to manipulate data associated with this template instance.</p>
     *
     * JavaScript Info:
     * @method modelForElement
     * @param {HTMLElement} el  
     * 
     * @return {JavaScriptObject}
     */
     JavaScriptObject modelForElement(HTMLElement el);

}
